<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RZV Flexible Software Package Documentation: FSP Architecture</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RZV Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v3.0.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">FSP Architecture </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#renesas-ra-software-package-fsp-architecture">FSP Architecture Overview</a><ul><li class="level2"><a href="#c99-use">C99 Use</a></li>
<li class="level2"><a href="#doxygen">Doxygen</a></li>
<li class="level2"><a href="#weak-symbols">Weak Symbols</a></li>
<li class="level2"><a href="#memory-allocation">Memory Allocation</a></li>
<li class="level2"><a href="#fsp-terms">FSP Terms</a></li>
</ul>
</li>
<li class="level1"><a href="#fsp-modules">FSP Modules</a><ul><li class="level2"><a href="#module-sources">Module Sources</a></li>
<li class="level2"><a href="#module-distribution">Module Distribution</a></li>
<li class="level2"><a href="#module-versioning">Module Versioning</a></li>
</ul>
</li>
<li class="level1"><a href="#fsp-stacks">FSP Stacks</a></li>
<li class="level1"><a href="#fsp-interfaces">FSP Interfaces</a><ul><li class="level2"><a href="#fsp-interface-enumerations">FSP Interface Enumerations</a></li>
<li class="level2"><a href="#fsp-interface-callback-functions">FSP Interface Callback Functions</a></li>
<li class="level2"><a href="#fsp-internface-data-structures">FSP Interface Data Structures</a><ul><li class="level3"><a href="#fsp-interface-configuration-structure">FSP Interface Configuration Structure</a></li>
<li class="level3"><a href="#fsp-interface-api-structure">FSP Interface API Structure</a></li>
<li class="level3"><a href="#fsp-instance-structure">FSP Interface Instance Structure</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#fsp-instances">FSP Instances</a><ul><li class="level2"><a href="#control-structure">FSP Instance Control Structure</a></li>
<li class="level2"><a href="#fsp-interface-extensions">FSP Interface Extensions</a><ul><li class="level3"><a href="#fsp-extended-configuration-structure">FSP Extended Configuration Structure</a></li>
</ul>
</li>
<li class="level2"><a href="#fsp-instance-api">FSP Instance API</a></li>
</ul>
</li>
<li class="level1"><a href="#fsp-api-standards">FSP API Standards</a><ul><li class="level2"><a href="#fsp-function-names">FSP Function Names</a></li>
<li class="level2"><a href="#use-of-const-in-api-parameters">Use of const in API parameters</a></li>
<li class="level2"><a href="#fsp-version-information">FSP Version Information</a></li>
</ul>
</li>
<li class="level1"><a href="#fsp-build-time-configurations">FSP Build Time Configurations</a></li>
<li class="level1"><a href="#fsp-file-structure">FSP File Structure</a></li>
<li class="level1"><a href="#fsp-architecture-in-practice">FSP Architecture in Practice</a><ul><li class="level2"><a href="#fsp-connecting-layers">FSP Connecting Layers</a></li>
<li class="level2"><a href="#using-fsp-modules-in-an-application">Using FSP Modules in an Application</a><ul><li class="level3"><a href="#create-a-module-instance">Create a Module Instance in the RZ Configuration Editor</a></li>
<li class="level3"><a href="#use-the-instance-api">Use the Instance API in the Application</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="renesas-ra-software-package-fsp-architecture"></a>
FSP Architecture Overview</h1>
<p>This guide describes the Renesas Flexible Software Package (FSP) architecture and how to use the FSP Application Programming Interface (API).</p>
<h2><a class="anchor" id="c99-use"></a>
C99 Use</h2>
<p>FSP uses the ISO/IEC 9899:1999 (C99) C programming language standard. Specific features introduced in C99 that are used include standard integer types (stdint.h), booleans (stdbool.h), designated initializers, and the ability to intermingle declarations and code.</p>
<h2><a class="anchor" id="doxygen"></a>
Doxygen</h2>
<p>Doxygen is the default documentation tool used by FSP. You can find Doxygen comments throughout the FSP source.</p>
<h2><a class="anchor" id="weak-symbols"></a>
Weak Symbols</h2>
<p>Weak symbols are used occasionally in FSP. They are used to ensure that a project builds even when the user has not defined an optional function.</p>
<h2><a class="anchor" id="memory-allocation"></a>
Memory Allocation</h2>
<p>Dynamic memory allocation through use of the malloc() and free() functions are not used in FSP modules; all memory required by FSP modules is allocated in the application and passed to the module in a pointer. Exceptions are considered only for ports of 3rd party code that require dynamic memory.</p>
<h2><a class="anchor" id="fsp-terms"></a>
FSP Terms</h2>
<table class="doxtable">
<tr>
<th>Term </th><th>Description </th><th>Reference  </th></tr>
<tr>
<td>BSP </td><td>Short for Board Support Package. In FSP, the BSP provides just enough foundation to allow other FSP modules to work together without issue. </td><td><a class="el" href="group___b_s_p___m_c_u.html">MPU Board Support Package</a> </td></tr>
<tr>
<td>Module </td><td>Modules can be peripheral drivers, purely software, or anything in between. Each module consists of a folder with source code, documentation, and anything else that the customer needs to use the code effectively. Modules are independent units, but they may depend on other modules. Applications can be built by combining multiple modules to provide the user with the features they need. </td><td><a class="el" href="_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html#fsp-modules">FSP Modules</a> </td></tr>
<tr>
<td>Driver </td><td>A driver is a specific kind of module that directly modifies registers on the MPU. </td><td>- </td></tr>
<tr>
<td>Interface </td><td>An interface contains API definitions that can be shared by modules with similar features. Interfaces are definitions only and do not add to code size. </td><td><a class="el" href="_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html#fsp-interfaces">FSP Interfaces</a> </td></tr>
<tr>
<td>Stacks </td><td>The FSP architecture is designed such that modules work together to form a stack. A stack consists of a top level module and all its dependencies. </td><td><a class="el" href="_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html#fsp-stacks">FSP Stacks</a> </td></tr>
<tr>
<td>Module Instance </td><td>An instance that summarizes the module information. </td><td>- </td></tr>
<tr>
<td>Application </td><td>Code that is owned and maintained by the user. Application code may be based on sample application code provided by Renesas, but it is the responsibility of the user to maintain as necessary. </td><td>- </td></tr>
<tr>
<td>Callback Function </td><td>This term refers to a function that is called when an event occurs. As an example, suppose the user would like to be notified every second based on the GPT. As part of the GPT configuration, a callback function can be supplied that will be jumped to during each GPT interrupt. When a single callback services multiple events, the arguments contain the triggering event. Callback functions for interrupts should be kept short and handled carefully because when they are called the MPU is still inside of an interrupt, delaying any pending interrupts. </td><td>- </td></tr>
</table>
<h1><a class="anchor" id="fsp-modules"></a>
FSP Modules</h1>
<p>Modules are the core building block of FSP. Modules can do many different things, but all modules share the basic concept of providing functionality upwards and requiring functionality from below.</p>
<div class="image">
<object type="image/svg+xml" data="figure-fsp-module_RZV.svg">figure-fsp-module_RZV.svg</object>
<div class="caption">
Modules</div></div>
<p> The amount of functionality provided by a module is determined based on functional use cases. Common functionality required by multiple modules is often placed into a self-contained submodule so it can be reused. Code size, speed and complexity are also considered when defining a module.</p>
<p>The simplest FSP application consists of one module with the Board Support Package (BSP) and the user application on top.</p>
<div class="image">
<object type="image/svg+xml" data="figure-fsp-application-single-module_RZV.svg">figure-fsp-application-single-module_RZV.svg</object>
<div class="caption">
Module with application</div></div>
<p> The Board Support Package (BSP) is the foundation for FSP modules, providing functionality to determine the MPU used as well as configuring clocks, interrupts and pins. For the sake of clarity, the BSP will be omitted from further diagrams.</p>
<h2><a class="anchor" id="module-sources"></a>
Module Sources</h2>
<p>Some modules distributed alongside FSP originate from outside sources. A full list of sources for FSP modules, including versions and hyperlinks, can be found in the Third Party Software section of the release notes for each release.</p>
<h2><a class="anchor" id="module-distribution"></a>
Module Distribution</h2>
<p>All modules distributed with FSP are packaged as CMSIS components in CMSIS packs. Each module consists of source files and a tooling support file used to integrate the module with e&sup2; studio or RASC. The tooling support file defines the configurations used to generate code in the ra_gen and ra_cfg folders.</p>
<h2><a class="anchor" id="module-versioning"></a>
Module Versioning</h2>
<p>Module versions can be seen on the Components tab of the FSP Configuration editor. The FSP Configuration editor automatically selects compatible components.</p>
<p>All third party modules have a semantic version are versioned with their original semantic version plus added metadata <code>fsp.&lt;fsp_semantic_version&gt;</code>. The metadata is added to reflect the tooling support file added for the FSP configuration tool.</p>
<p>Third party modules versioned with <code>+renesas.&lt;counter&gt;</code> in the metadata have been forked and updated for FSP. If <code>+renesas.&lt;counter&gt;</code> is not in the metadata, the third party code is unchanged from its original source.</p>
<p>If changes are made to third party module source code to support FSP, the changes are pushed to a public Renesas GitHub fork of the original source. Links to Renesas forks are provided in the Third Party Software section of the release notes for each release.</p>
<p>Modules that originate from outside sources that do not have a semantic version are versioned with the FSP version.</p>
<p>All modules that are part of FSP or integrated with FSP are tested as a package. Mixing versions is not encouraged and may lead to support issues.</p>
<h1><a class="anchor" id="fsp-stacks"></a>
FSP Stacks</h1>
<p>When modules are layered atop one another, an FSP stack is formed. The stacking process is performed by matching what one module provides with what another module requires. For example, the SPI module (<a class="el" href="group___s_p_i___b.html">SPI (r_spi_b)</a>)</p>
<p>requires a module that provides the transfer interface (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html">Transfer Interface</a>) to send or receive data without a CPU interrupt. The transfer interface requirement can be fulfilled by the DMAC driver module (<a class="el" href="group___d_m_a_c___b.html">Direct Memory Access Controller (r_dmac_b)</a>).</p>
<p>Through this methodology the same code can be shared by several modules simultaneously. The example below illustrates how the same DMAC module can be used with SPI (<a class="el" href="group___s_p_i___b.html">SPI (r_spi_b)</a>), UART (<a class="el" href="group___s_c_i___b___u_a_r_t.html">UART (r_sci_b_uart)</a>) and I2C Master (<a class="el" href="group___r_i_i_c___m_a_s_t_e_r.html">I2C Master on RIIC (r_riic_master)</a>).</p>
<div class="image">
<object type="image/svg+xml" data="figure-fsp-multiple-drivers-use-dmac_RZV.svg">figure-fsp-multiple-drivers-use-dmac_RZV.svg</object>
<div class="caption">
Stacks -- Shared DMAC Module</div></div>
<p> The ability to stack modules ensures the flexibility of the architecture as a whole. If multiple modules include the same functionality issues arise when application features must work across different user designs. To ensure that modules are reusable, any dependent modules must be capable of being swapped out for other modules that provide the same features. The FSP architecture provides this flexibility to swap modules in and out through the use of FSP interfaces.</p>
<h1><a class="anchor" id="fsp-interfaces"></a>
FSP Interfaces</h1>
<p>At the architecture level, interfaces are the way that modules provide common features. This commonality allows modules that adhere to the same interface to be used interchangeably. Interfaces can be thought of as a contract between two modules - the modules agree to work together using the information that was established in the contract.</p>
<p>On RZ hardware there is occasionally an overlap of features between different peripherals. For example, I2C communications can be achieved through use of the IIC peripheral or the SCI peripheral. However, there is a difference in the level of features provided by both peripherals; in I2C mode the SCI peripheral will only support a subset of the capabilities of the fully-featured I2C.</p>
<p>Interfaces aim to provide support for the common features that most users would expect. This means that some of the advanced features of a peripheral (such as IIC) might not be available in the interface. In most cases these features are still available through interface extensions.</p>
<p>In FSP design, interfaces are defined in header files. All interface header files are located in the folder <code>rzv/fsp/inc/api</code> and end with <code>*_api.h</code>. Interface extensions are defined in header files in the folder <code>rzv/fsp/inc/instances</code>. The following sections detail what makes up an interface.</p>
<h2><a class="anchor" id="fsp-interface-enumerations"></a>
FSP Interface Enumerations</h2>
<p>Whenever possible, interfaces use typed enumerations for function parameters and structure members.</p>
 <div class="fragment"><div class="line">typedef enum e_i2c_master_addr_mode</div><div class="line">{</div><div class="line">    I2C_MASTER_ADDR_MODE_7BIT  = 1,    ///&lt; Use 7-bit addressing mode</div><div class="line">    I2C_MASTER_ADDR_MODE_10BIT = 2,    ///&lt; Use 10-bit addressing mode</div><div class="line">} i2c_master_addr_mode_t;</div></div><!-- fragment --></p>
<p>Enumerations remove uncertainty when deciding what values are available for a parameter. FSP enumeration options follow a strict naming convention where the name of the type is prefixed on the available options. Combining the naming convention with the autocomplete feature available in e&sup2; studio (Ctrl + Space) provides the benefits of rapid coding while maintaining high readability.</p>
<h2><a class="anchor" id="fsp-interface-callback-functions"></a>
FSP Interface Callback Functions</h2>
<p>Callback functions allow modules to asynchronously alert the user application when an event has occurred, such as when a byte has been received over a UART channel or an IRQ pin is toggled. FSP driver modules define and handle the interrupt service routines for RZ MPU peripherals to ensure any required hardware procedures are implemented. The interrupt service routines in FSP modules then call the user-defined callbacks to allow the application to respond.</p>
<p>Callback functions must be defined in the user application. They always return <code>void</code> and take a structure for their one parameter. The structure is defined in the interface for the module and is named <code>&lt;interface&gt;_callback_args_t</code>. The contents of the structure may vary depending on the interface, but two members are common: <code>event</code> and <code>p_context</code>.</p>
<p>The <code>event</code> member is an enumeration defined in the interface used by the application to determine why the callback was called. Using the UART example, the callback could be triggered for many different reasons, including when a byte is received, all bytes have been transmitted, or a framing error has occurred. The <code>event</code> member allows the application to determine which of these three events has occurred and handle it appropriately.</p>
<p>The <code>p_context</code> member is used for providing user-specified data to the callback function. In many cases a callback function is shared between multiple channels or module instances; when the callback occurs, the code handling the callback needs context information so that it can determine which module instance the callback is for. For example, if the callback wanted to make an FSP API call in the callback, then at a minimum the callback will need a reference to the relevant control structure. To make this easy, the user can provide a pointer to the control structure as the <code>p_context</code>. When the callback occurs, the control structure is passed in the <code>p_context</code> element of the callback structure.</p>
<p>Callback functions are called from within an interrupt service routine. For this reason callback functions should be kept as short as possible so they do not affect the real time performance of the user's system. An example of a callback function that is called from the timer module's interrupt handler to blink an LED is shown below.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> timer_callback (<a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__callback__args__t">timer_callback_args_t</a> * <span class="keyword">const</span> p_unused)</div><div class="line">{</div><div class="line">    (void) p_unused;</div><div class="line"></div><div class="line">    <span class="comment">/* Holds level to set for pins */</span></div><div class="line">    <span class="keyword">static</span> <a class="code" href="group___b_s_p___i_o.html#gab4ef0cc3fce421d48310f23c614aadc0">bsp_io_level_t</a> pin_level = <a class="code" href="group___b_s_p___i_o.html#ggab4ef0cc3fce421d48310f23c614aadc0abb31064742440cdbdd638330a1cf7a9f">BSP_IO_LEVEL_LOW</a>;</div><div class="line"></div><div class="line">    <span class="comment">/* Update all board LEDs */</span></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; g_bsp_leds.led_count; i++)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Get pin to toggle */</span></div><div class="line"></div><div class="line">        uint32_t pin = g_bsp_leds.p_leds[i];</div><div class="line"></div><div class="line">        <span class="comment">/* Write to this pin */</span></div><div class="line"></div><div class="line">        <a class="code" href="group___b_s_p___i_o.html#ga33cef14f93543bcb3531b4f2e377c5c4">R_BSP_PinWrite</a>((<a class="code" href="group___b_s_p___i_o.html#ga0adbfd4b7db319886d667acb4804d80a">bsp_io_port_pin_t</a>) pin, pin_level);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Toggle level for next write */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___b_s_p___i_o.html#ggab4ef0cc3fce421d48310f23c614aadc0abb31064742440cdbdd638330a1cf7a9f">BSP_IO_LEVEL_LOW</a> == pin_level)</div><div class="line">    {</div><div class="line">        pin_level = <a class="code" href="group___b_s_p___i_o.html#ggab4ef0cc3fce421d48310f23c614aadc0acf9a28559b5a18ed9b8af4c2a7df10ef">BSP_IO_LEVEL_HIGH</a>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        pin_level = <a class="code" href="group___b_s_p___i_o.html#ggab4ef0cc3fce421d48310f23c614aadc0abb31064742440cdbdd638330a1cf7a9f">BSP_IO_LEVEL_LOW</a>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> Also, there are cases where users do not need to create callback functions, as shown below. When a module is not directly used in the user application (that is, it is not the top layer of the stack), its callback function will be handled by the module above. For example, if a module requires a UART interface module the upper layer module will control and use the UART's callback function. In this case the user would not need to create a callback function for the UART module in their application code.</p>
<h2><a class="anchor" id="fsp-internface-data-structures"></a>
FSP Interface Data Structures</h2>
<p>At a minimum, all FSP interfaces include three data structures: a configuration structure, an API structure, and an instance structure.</p>
<h3><a class="anchor" id="fsp-interface-configuration-structure"></a>
FSP Interface Configuration Structure</h3>
<p>The configuration structure is used for the initial configuration of a module during the <code>&lt;MODULE&gt;_Open()</code> call. The structure consists of members such as channel number, bitrate, and operating mode.</p>
<p>The configuration structure is used purely as an input into the module. It may be stored and referenced by the module, so the configuration structure and anything it references must persist as long as the module is open.</p>
<p>The configuration structure is allocated for each module instance in files generated by the RZ Configuration editor.</p>
<p>When FSP stacks are used, it is also important to understand that configuration structures only have members that apply to the current interface. If multiple layers in the same stack define the same configuration parameters then it becomes difficult to know where to modify the option. For example, the baud rate for a UART is only defined in the UART module instance. Any modules that use the UART interface rely on the baud rate being provided in the UART module instance and do not offer it in their own configuration structures.</p>
<h3><a class="anchor" id="fsp-interface-api-structure"></a>
FSP Interface API Structure</h3>
<p>All interfaces include an API structure which contains function pointers for all the supported interface functions. An example structure for the <a class="el" href="group___a_d_c___e.html">Analog to Digital Converter (r_adc_e)</a> is shown below.</p>
 <div class="fragment"><div class="line">typedef struct st_adc_api</div><div class="line">{</div><div class="line">    /** Initialize ADC Unit;  apply power, set the operational mode, trigger sources, interrupt priority,</div><div class="line">     * and configurations common to all channels and sensors.</div><div class="line">     *</div><div class="line">     * @pre Configure peripheral clocks, ADC pins and IRQs prior to calling this function.</div><div class="line">     * @param[in]  p_ctrl  Pointer to control handle structure</div><div class="line">     * @param[in]  p_cfg   Pointer to configuration structure</div><div class="line">     */</div><div class="line">    fsp_err_t (* open)(adc_ctrl_t * const p_ctrl, adc_cfg_t const * const p_cfg);</div><div class="line"></div><div class="line">    /** Configure the scan including the channels, groups, and scan triggers to be used for the unit that</div><div class="line">     * was initialized in the open call.  Some configurations are not supported for all implementations.</div><div class="line">     * See implementation for details.</div><div class="line">     *</div><div class="line">     * @param[in]  p_ctrl     Pointer to control handle structure</div><div class="line">     * @param[in]  p_extend   See implementation for details</div><div class="line">     */</div><div class="line">    fsp_err_t (* scanCfg)(adc_ctrl_t * const p_ctrl, void const * const p_extend);</div><div class="line"></div><div class="line">    /** Start the scan (in case of a software trigger), or enable the hardware trigger.</div><div class="line">     *</div><div class="line">     * @param[in]  p_ctrl   Pointer to control handle structure</div><div class="line">     */</div><div class="line">    fsp_err_t (* scanStart)(adc_ctrl_t * const p_ctrl);</div><div class="line"></div><div class="line">    /** Start the scan group (in case of a software trigger), or enable the hardware trigger.</div><div class="line">     *</div><div class="line">     * @param[in]  p_ctrl     Pointer to control handle structure</div><div class="line">     * @param[in]  group_mask Mask of groups to start</div><div class="line">     */</div><div class="line">    fsp_err_t (* scanGroupStart)(adc_ctrl_t * p_ctrl, adc_group_mask_t group_mask);</div><div class="line"></div><div class="line">    /** Stop the ADC scan (in case of a software trigger), or disable the hardware trigger.</div><div class="line">     *</div><div class="line">     * @param[in]  p_ctrl   Pointer to control handle structure</div><div class="line">     */</div><div class="line">    fsp_err_t (* scanStop)(adc_ctrl_t * const p_ctrl);</div><div class="line"></div><div class="line">    /** Check scan status.</div><div class="line">     *</div><div class="line">     * @param[in]  p_ctrl   Pointer to control handle structure</div><div class="line">     * @param[out] p_status Pointer to store current status in</div><div class="line">     */</div><div class="line">    fsp_err_t (* scanStatusGet)(adc_ctrl_t * const p_ctrl, adc_status_t * p_status);</div><div class="line"></div><div class="line">    /** Read ADC conversion result.</div><div class="line">     *</div><div class="line">     * @param[in]  p_ctrl   Pointer to control handle structure</div><div class="line">     * @param[in]  reg_id   ADC channel to read (see enumeration adc_channel_t)</div><div class="line">     * @param[in]  p_data   Pointer to variable to load value into.</div><div class="line">     */</div><div class="line">    fsp_err_t (* read)(adc_ctrl_t * const p_ctrl, adc_channel_t const reg_id, uint16_t * const p_data);</div><div class="line"></div><div class="line">    /** Read ADC conversion result into a 32-bit word.</div><div class="line">     *</div><div class="line">     * @param[in]  p_ctrl   Pointer to control handle structure</div><div class="line">     * @param[in]  reg_id   ADC channel to read (see enumeration adc_channel_t)</div><div class="line">     * @param[in]  p_data   Pointer to variable to load value into.</div><div class="line">     */</div><div class="line">    fsp_err_t (* read32)(adc_ctrl_t * const p_ctrl, adc_channel_t const reg_id, uint32_t * const p_data);</div><div class="line"></div><div class="line">    /** Calibrate ADC or associated PGA (programmable gain amplifier).  The driver may require implementation specific</div><div class="line">     * arguments to the p_extend input. Not supported for all implementations. See implementation for details.</div><div class="line">     *</div><div class="line">     * @param[in]  p_ctrl    Pointer to control handle structure</div><div class="line">     * @param[in]  p_extend  Pointer to implementation specific arguments</div><div class="line">     */</div><div class="line">    fsp_err_t (* calibrate)(adc_ctrl_t * const p_ctrl, void const * p_extend);</div><div class="line"></div><div class="line">    /** Set offset for input PGA configured for differential input. Not supported for all implementations.</div><div class="line">     *  See implementation for details.</div><div class="line">     *</div><div class="line">     * @param[in]  p_ctrl    Pointer to control handle structure</div><div class="line">     * @param[in]  reg_id    ADC channel to read (see enumeration adc_channel_t)</div><div class="line">     * @param[in]  offset    See implementation for details.</div><div class="line">     */</div><div class="line">    fsp_err_t (* offsetSet)(adc_ctrl_t * const p_ctrl, adc_channel_t const reg_id, int32_t const offset);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Specify callback function and optional context pointer and working memory pointer.</div><div class="line">     *</div><div class="line">     * @param[in]   p_ctrl                   Pointer to the ADC control block.</div><div class="line">     * @param[in]   p_callback               Callback function</div><div class="line">     * @param[in]   p_context                Pointer to send to callback function</div><div class="line">     * @param[in]   p_working_memory         Pointer to volatile memory where callback structure can be allocated.</div><div class="line">     *                                       Callback arguments allocated here are only valid during the callback.</div><div class="line">     */</div><div class="line">    fsp_err_t (* callbackSet)(adc_ctrl_t * const p_ctrl, void (* p_callback)(adc_callback_args_t *),</div><div class="line">                              void const * const p_context, adc_callback_args_t * const p_callback_memory);</div><div class="line"></div><div class="line">    /** Close the specified ADC unit by ending any scan in progress, disabling interrupts, and removing power to the</div><div class="line">     * specified A/D unit.</div><div class="line">     *</div><div class="line">     * @param[in]  p_ctrl   Pointer to control handle structure</div><div class="line">     */</div><div class="line">    fsp_err_t (* close)(adc_ctrl_t * const p_ctrl);</div><div class="line"></div><div class="line">    /** Return the ADC data register address of the first (lowest number) channel and the total number of bytes</div><div class="line">     * to be read in order for the DTC/DMAC to read the conversion results of all configured channels.</div><div class="line">     * Return the temperature sensor calibration and slope data.</div><div class="line">     *</div><div class="line">     * @param[in]   p_ctrl       Pointer to control handle structure</div><div class="line">     * @param[out]  p_adc_info   Pointer to ADC information structure</div><div class="line">     */</div><div class="line">    fsp_err_t (* infoGet)(adc_ctrl_t * const p_ctrl, adc_info_t * const p_adc_info);</div><div class="line">} adc_api_t;</div></div><!-- fragment --></p>
<p>The API structure is what allows for modules to easily be swapped in and out for other modules that are instances of the same interface. Let's look at an example application using the ADC interface above.</p>
<p>RZ MPU have an internal ADC peripheral. If the ADC API structure in the ADC interface is not used the application can make calls directly into the module. In the example below the application is making calls to the <a class="el" href="group___a_d_c___e.html#ga1768d1f5986545eb95ab8273559eaee5">R_ADC_E_Read()</a> function which is provided in the r_adc_e module.</p>
<div class="image">
<object type="image/svg+xml" data="figure-fsp-adc_e-read_RZV.svg">figure-fsp-adc_e-read_RZV.svg</object>
<div class="caption">
ADC Read example</div></div>
<p> Now let's assume that the user needs more ADC channels than are available on the MPU and decides to add an external ADC module named adc_external using I2C for communications. The application must now distinguish between the two modules, adding complexity and further dependencies to the application.</p>
<div class="image">
<object type="image/svg+xml" data="figure-fsp-external-adc_RZV.svg">figure-fsp-external-adc_RZV.svg</object>
<div class="caption">
ADC Read with two read modules</div></div>
<p> The use of interfaces and the API structure allows for the use of an abstracted ADC. This means that no extra logic is needed if the user's adc_external module implements the FSP ADC interface, so the application no longer depends upon hard-coded module function names. Instead the application now depends on the ADC interface API which can be implemented by any number of modules.</p>
<div class="image">
<object type="image/svg+xml" data="figure-fsp-adc-interface_RZV.svg">figure-fsp-adc-interface_RZV.svg</object>
<div class="caption">
ADC Interface</div></div>
 <h3><a class="anchor" id="fsp-instance-structure"></a>
FSP Interface Instance Structure</h3>
<p>Every FSP interface also has an instance structure. The instance structure encapsulates everything required to use the module:</p>
<ul>
<li>A pointer to the instance API structure (<a class="el" href="_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html#fsp-instance-api">FSP Instance API</a>)</li>
<li>A pointer to the configuration structure</li>
<li>A pointer to the control structure</li>
</ul>
<p>The instance structure is not required at the application layer. It is used to connect modules to their dependencies (other than the BSP).</p>
<p>Instance structures have a standardized name of <code>&lt;interface&gt;_instance_t</code>. An example from the <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html">Transfer Interface</a> is shown below.</p>
 <div class="fragment"><div class="line">typedef struct st_transfer_instance</div><div class="line">{</div><div class="line">    transfer_ctrl_t      * p_ctrl;     ///&lt; Pointer to the control structure for this instance</div><div class="line">    transfer_cfg_t const * p_cfg;      ///&lt; Pointer to the configuration structure for this instance</div><div class="line">    transfer_api_t const * p_api;      ///&lt; Pointer to the API structure for this instance</div><div class="line">} transfer_instance_t;</div></div><!-- fragment --></p>
<p>Note that when an instance structure variable is declared, the API is the only thing that is instance specific, not <em>module instance</em> specific. This is because all module instances of the same module share the same underlying module source code. If SPI is being used on SCI channels 0 and 2 then both module instances use the same API while the configuration and control structures are typically different.</p>
<h1><a class="anchor" id="fsp-instances"></a>
FSP Instances</h1>
<p>While interfaces dictate the features that are provided, instances actually implement those features. Each instance is tied to a specific interface. Instances use the enumerations, data structures, and API prototypes from the interface. This allows an application that uses an interface to swap out the instance when needed.</p>
<p>On RZ MPUs some peripherals are used to implement multiple interfaces. In the example below the IIC, UART and SPI peripherals map to only one interface each while the SCI peripheral implements three interfaces.</p>
<div class="image">
<object type="image/svg+xml" data="figure-fsp-interface-implementation-example_RZV.svg">figure-fsp-interface-implementation-example_RZV.svg</object>
<div class="caption">
Instances</div></div>
<p> In FSP design, instances consist of the interface extension and API defined in the instance header file located in the folder <code>rz/fsp/inc/instances</code> and the module source <code>rzv/fsp/src/&lt;module&gt;</code>.</p>
<h2><a class="anchor" id="control-structure"></a>
FSP Instance Control Structure</h2>
<p>The control structure is used as a unique identifier for the module instance and contains memory required by the module. Elements in the control structure are owned by the module and <em>must not be modified</em> by the application. The user allocates storage for a control structure, often as a global variable, then sends a pointer to it into the <code>&lt;MODULE&gt;_Open()</code> call for a module. At this point, the module initializes the structure as needed. The user must then send in a pointer to the control structure for all subsequent module calls.</p>
<h2><a class="anchor" id="fsp-interface-extensions"></a>
FSP Interface Extensions</h2>
<p>In some cases, instances require more information than is provided in the interface. This situation can occur in the following cases:</p>
<ul>
<li>An instance offers extra features that are not common to most instances of the interface. An example of this is the start source selection of the GPT (<a class="el" href="group___g_p_t.html">General PWM Timer (r_gpt)</a>). The GPT can be configured to start based on hardware events such as a falling edge on a trigger pin. This feature is not common to all timers, so it is included in the GPT instance.</li>
</ul>
<p>The <code>p_extend</code> member provides this extension function.</p>
<p>Use of interface extensions is not always necessary. Some instances do not offer an extension since all functionality is provided in the interface. In these cases the <code>p_extend</code> member can be set to NULL. The documentation for each instance indicates whether an interface extension is available and whether it is mandatory or optional.</p>
<h3><a class="anchor" id="fsp-extended-configuration-structure"></a>
FSP Extended Configuration Structure</h3>
<p>When extended configuration is required it can be supplied through the <code>p_extend</code> parameter of the interface configuration structure.</p>
<p>The extended configuration structure is part of the instance, but it is also still considered to be part of the configuration structure. All usage notes about the configuration structure described in <a class="el" href="_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html#fsp-interface-configuration-structure">FSP Interface Configuration Structure</a> apply to the extended configuration structure as well.</p>
<p>The extended configuration structure and all typed structures and enumerations required to define it make up the interface extension.</p>
<h2><a class="anchor" id="fsp-instance-api"></a>
FSP Instance API</h2>
<p>Each instance includes a constant global variable tying the interface API functions to the functions provided by the module. The name of this structure is standardized as <code>g_&lt;interface&gt;_on_&lt;instance&gt;</code>. Examples include g_spi_on_spi_b, g_transfer_on_dmac, and g_adc_on_adc_e. This structure is available to be used through an extern in the instance header file (r_spi_b.h, r_dmac.h, and r_adc_e.h respectively).</p>
<h1><a class="anchor" id="fsp-api-standards"></a>
FSP API Standards</h1>
<h2><a class="anchor" id="fsp-function-names"></a>
FSP Function Names</h2>
<p>FSP functions start with the uppercase module name (<code>&lt;MODULE&gt;</code>). All modules have <code>&lt;MODULE&gt;_Open()</code> and <code>&lt;MODULE&gt;_Close()</code> functions. The <code>&lt;MODULE&gt;_Open()</code> function must be called before any of the other functions.</p>
<p>Other functions that will commonly be found are <code>&lt;MODULE&gt;_Read()</code>, <code>&lt;MODULE&gt;_Write()</code>, <code>&lt;MODULE&gt;_InfoGet()</code>, and <code>&lt;MODULE&gt;_StatusGet()</code>. The <code>&lt;MODULE&gt;_StatusGet()</code> function provides a status that could change asynchronously, while <code>&lt;MODULE&gt;_InfoGet()</code> provides information that cannot change after open or can only be updated by API calls. Example function names include:</p>
<ul>
<li><a class="el" href="group___s_p_i___b.html#gabcc557f95c75b12b462962f6c709e229">R_SPI_B_Read()</a>, <a class="el" href="group___s_p_i___b.html#ga2adf0b091362e84b71f1bd3a1d821f40">R_SPI_B_Write()</a>, <a class="el" href="group___s_p_i___b.html#ga44658a0ea656e093e0eac61186aef274">R_SPI_B_WriteRead()</a></li>
<li><a class="el" href="group___g_t_m.html#gaa95357cd0d4d8c43f7a2523d4c3b24f7">R_GTM_StatusGet()</a></li>
<li><a class="el" href="group___r_t_c.html#ga5c39b02432cedcb7a29ae8bdc8fcefb8">R_RTC_CalendarAlarmSet()</a>, <a class="el" href="group___r_t_c.html#gacbb2641ed2236f071c001df6b025e0f2">R_RTC_CalendarAlarmGet()</a></li>
<li><a class="el" href="group___g_p_t.html#gafedbfd8bc3f534d06969588ff10a351b">R_GPT_PeriodSet()</a>, <a class="el" href="group___g_p_t.html#gaca62ac33de2c05918b0fc359aeaebd97">R_GPT_InfoGet()</a></li>
</ul>
<h2><a class="anchor" id="use-of-const-in-api-parameters"></a>
Use of const in API parameters</h2>
<p>The <code>const</code> qualifier is used with API parameters whenever possible. An example case is shown below.</p>
 <div class="fragment"><div class="line">fsp_err_t R_GTM_Open(timer_ctrl_t * const p_ctrl, timer_cfg_t const * const p_cfg);</div></div><!-- fragment --></p>
<p>In this example, <code><a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__cfg__t">timer_cfg_t</a></code> is a structure of configuration parameters for the r_gtm module. The parameter <code>p_cfg</code> is a pointer to this structure. The first <code>const</code> qualifier on <code>p_cfg</code> ensures the <code><a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__cfg__t">timer_cfg_t</a></code> structure cannot be modified by <a class="el" href="group___g_t_m.html#ga329fac4f1af8dee4e45200fd0ce5a9a5">R_GTM_Open()</a>. This allows the structure to be allocated as a const variable and stored in ROM instead of RAM.</p>
<p>The <code>const</code> qualifier after the pointer star for both <code>p_ctrl</code> and <code>p_cfg</code> ensures the FSP function does not modify the input pointer addresses. While not fool-proof by any means this does provide some extra checking inside the FSP code to ensure that arguments that should not be altered are treated as such.</p>
<h2><a class="anchor" id="fsp-version-information"></a>
FSP Version Information</h2>
<p>The BSP provides a function <code><a class="el" href="group___b_s_p___m_c_u.html#gaf3ee66233fc75acfcc21a97d7a767aa1">R_FSP_VersionGet()</a></code> which fills in a structure of type <code><a class="el" href="group___r_e_n_e_s_a_s___c_o_m_m_o_n.html#unionfsp__pack__version__t">fsp_pack_version_t</a></code>. This can be used to determine the FSP version at runtime.</p>
<p>There are also <code>FSP_VERSION_*</code> macros in fsp_version.h that can be used to determine the FSP version at build time.</p>
<h1><a class="anchor" id="fsp-build-time-configurations"></a>
FSP Build Time Configurations</h1>
<p>All modules have a build-time configuration header file. Most configuration options are supplied at run time, though options that are rarely used or apply to all instances of a module may be moved to build time. The advantage of using a build-time configuration option is to potentially reduce code size reduction by removing an unused feature.</p>
<p>All modules have a build time option to enable or disable parameter checking for the module. FSP modules check function arguments for validity when possible, though this feature is disabled by default to reduce code size. Enabling it can help catch parameter errors during development and debugging. By default, each module's parameter checking configuration inherits the BSP parameter checking setting (set on the BSP tab of the RZ Configuration editor). Leaving each module's parameter checking configuration set to Default (BSP) allows parameter checking to be enabled or disabled globally in all FSP code through the parameter checking setting on the BSP tab.</p>
<p>If an error condition can reasonably be avoided it is only checked in a section of code that can be disabled by disabling parameter checking. Most FSP APIs can only return FSP_SUCCESS if parameter checking is disabled. An example of an error that cannot be reasonably avoided is the "bus busy" error that occurs when another master is using an I2C bus. This type of error can be returned even if parameter checking is disabled.</p>
<h1><a class="anchor" id="fsp-file-structure"></a>
FSP File Structure</h1>
<p>The high-level file structure of an FSP project is shown below.</p>
<div class="fragment"><div class="line">rzv_gen</div><div class="line"></div><div class="line">rzv</div><div class="line"></div><div class="line">+---fsp</div><div class="line"></div><div class="line">    +---inc</div><div class="line"></div><div class="line">    |   +---api</div><div class="line"></div><div class="line">    |   \---instances</div><div class="line"></div><div class="line">    \---src</div><div class="line"></div><div class="line">        +---bsp</div><div class="line"></div><div class="line">        \---r_&lt;MODULE&gt; (Folder containing the source code for each driver)</div><div class="line"></div><div class="line">rzv_cfg</div><div class="line"></div><div class="line">+---fsp_cfg</div><div class="line"></div><div class="line">    +---bsp</div><div class="line"></div><div class="line">    +---r_&lt;MODULE&gt;_cfg.h (cfg files for each driver)</div></div><!-- fragment --><p>Directly underneath the base <code>rzv</code> folder the folders are split into the source and include folders. Include folders are kept separate from the source for easy browsing and easy setup of include paths.</p>
<p>The <code>rzv_gen</code> folder contains code generated by the RZ Configuration editor. This includes global variables for the control structure and configuration structure for each module.</p>
<p>The <code>rzv_cfg</code> folder is where configuration header files are stored for each module. See <a class="el" href="_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html#fsp-build-time-configurations">FSP Build Time Configurations</a> for information on what is provided in these header files.</p>
<h1><a class="anchor" id="fsp-architecture-in-practice"></a>
FSP Architecture in Practice</h1>
<h2><a class="anchor" id="fsp-connecting-layers"></a>
FSP Connecting Layers</h2>
<p>FSP modules are meant to be both reusable and stackable. It is important to remember that modules are not dependent upon other modules, but upon other interfaces. The user is then free to fulfill the interface using the instance that best fits their needs.</p>
<div class="image">
<object type="image/svg+xml" data="figure-fsp-interface-dependency-connection_RZV.svg">figure-fsp-interface-dependency-connection_RZV.svg</object>
<div class="caption">
Connecting layers</div></div>
<p> In the image above interface Y is a dependency of interface X and has its own dependency on interface Z. Interface X only has a dependency on interface Y. Interface X has no knowledge of interface Z. This is a requirement for ensuring that layers can easily be swapped out.</p>
<h2><a class="anchor" id="using-fsp-modules-in-an-application"></a>
Using FSP Modules in an Application</h2>
<p>The typical use of an FSP module involves generating required module data then using the API in the application.</p>
<h3><a class="anchor" id="create-a-module-instance"></a>
Create a Module Instance in the RZ Configuration Editor</h3>
<p>The RZ Configuration editor (available both in the Renesas e&sup2; studio IDE as well as through the standalone RZ Smart Configurator) provides a graphical user interface for setting the parameters of the interface and instance configuration structures. It also automatically includes those structures (once they are configured in the GUI) in application-specific header files that can be included in application code.</p>
<p>The RZ Configuration editor allocates storage for the control structures, all required configuration structures, and the instance structure in generated files in the <code>rzv_gen</code> folder. Use the <b>Properties</b> window to set the values for the members of the configuration structures as needed. Refer to the Configuration section of the module usage notes for documentation about the configuration options.</p>
<p>If the interface has a callback function option then the application must declare and define the function. The return value is always of type <code>void</code> and the parameter to the function is a typed structure of name <code>&lt;interface&gt;_callback_args_t</code>. Once the function has been defined, assign its name to the <code>p_callback</code> member of the configuration structure. Callback function names can be assigned through the <b>Properties</b> window for the selected module.</p>
<h3><a class="anchor" id="use-the-instance-api"></a>
Use the Instance API in the Application</h3>
<p>Call the module's <code>&lt;MODULE&gt;_Open()</code> function. Pass pointers to the generated control structure and configuration structure. The names of these structures are based on the 'Name' field provided in the configuration editor. The control structure is <code>&lt;Name&gt;_ctrl</code> and the configuration structure is <code>&lt;Name&gt;_cfg</code>. An example <code>&lt;MODULE&gt;_Open()</code> call for an r_gtm module instance named <code>g_timer</code> is:</p>
<div class="fragment"><div class="line"></div><div class="line">    <a class="code" href="group___g_t_m.html#ga329fac4f1af8dee4e45200fd0ce5a9a5">R_GTM_Open</a>(&amp;g_timer_ctrl, &amp;g_timer_cfg);</div><div class="line"></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Each layer in the FSP Stack is responsible for calling the API functions of its dependencies. This means that users are only responsible for calling the API functions at the layer at which they are interfacing. Using the example above of a SPI module with a DMAC dependency, the application uses only SPI APIs. The application starts by calling <a class="el" href="group___s_p_i___b.html#gab338db9c94dc09edc2ceddf87904845d">R_SPI_B_Open()</a>. Internally, the SPI module opens the DMAC. It locates <a class="el" href="group___d_m_a_c___b.html#gac246f431e5d9b090d51fa82e1cf4c525">R_DMAC_B_Open()</a> by accessing the dependent transfer interface function pointers from the pointers DMAC instances (<a class="el" href="group___s_p_i___a_p_i.html#a312e4358f12551a3f7aaa5f0a09c0501" title="To use SPI DTC/DMAC write transfer, link a transfer instance here. Set to NULL if unused...">spi_cfg_t::p_transfer_tx</a> and <a class="el" href="group___s_p_i___a_p_i.html#ab38fb6af687bdf7e0ea9143499849bc6" title="To use SPI DTC/DMAC read transfer, link a transfer instance here. Set to NULL if unused. ">spi_cfg_t::p_transfer_rx</a>) to open the DMAC.</dd></dl>
<p>Refer to the module usage notes for example code to help get started with any particular module. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v3.0.0 User's Manual Copyright © (2024) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
